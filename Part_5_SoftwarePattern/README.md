# :mortar_board: AUTOMATION SERVICE CHOREOGRAPHY

[:rewind:back](../README.md)

## :five: Software Pattern for Automation Choreographies



## Conceptional Overview

![abstract_perspective](../Media/abstract_architecture.png)

The conceptional overview starts with the system perspective on a choreography shown in Figure \ref{figure:abstract_perspective}. The figure, inspired by exemplary use case in Figure \ref{fig:usecase}, shows three interconnected PEAs with their four services. From a system perspective, a choreography consists of three different types of building blocks — environments, services, and relations.\\
An \textbf{environment} represents the execution context of services, this can be a PLC or an embedded device. It provides basic functionality regarding data processing and communication.\\
A \textbf{service} exists within such an environment and fulfills an automated functionality. Each of the services is able to observe other services within the choreography boundaries and act according to their status. These observing dependencies are called relations.\\
A \textbf{relation} is represented as an arrow directed from the observing to the observed service. Relations shall be configurable without a new download of the controller software. As shown in Figure 5 two types of relations can be distinguished: Internal relations connect services within the same environment (see Figure \ref{figure:abstract_perspective}, between \textit{Filling} and \textit{Stirring}). External relations connect services across environment boundaries (see Figure \ref{figure:abstract_perspective}, between \textit{Dosing} and \textit{Filling}). With respect to an automation function a relation consists of a set of procedural, regulatory and interlocking signals \cite{ICPS}. Whereas the procedural signals represent state-based information, the regulatory and interlocking signals are continuous information. From the perspective of an environment, the sum of all observed signals out of all relations of the contained services is called signal-space.

As example for such a signal-space a simplified setup of the PEA2 environment in Figure \ref{figure:abstract_perspective} is described. The \textit{Analyzing} service provides state information as well as a continuous process value of the measured pH-value. The \textit{Filling} service also provides state information and  interlocking information of a level switch to protect the tank against overfilling and the position information of the inlet valve to avoid pumping against a closed valve. The \textit{Dosing} service has observer relations to the \textit{Filling} and the \textit{Analyzing} service. Following the given information, the signal-space of the \textit{Dosing} service consists of five signals — two state information signals (procedural), the pH-value that is used to control the flow rate into the reactor (regulatory) and the interlocking signals from the level switch and the valve of the reactor (interlocking).

In general, the presented way of functioning of a choreography requires environments that have three major capabilities — external communication, signal-space forming and services that are able to perform actions in case of observed signal changes.

![detail_perspective](../Media/detail_single_architecture.png)

An architectural approach for the realization of these three capabilities is presented in Figure \ref{figure:detail_perspective}. From the software point of view the environment consist of an \textit{ExternalCommunication} component, a \textit{SignalSpace} component containing external and internal information and the \textit{ChoreographableService}. The latter can be further separated into a \textit{CoreService} and an \textit{Actioner} component.

The component \textbf{\textit{ExternalCommunication}} reads external signals by using a vendor-independent communication technology. For example, with OPC UA, a suitable standardized communication technology exists. Its client-server architecture can be used to realize the observer relations. With the software pattern described in subsection \ref{subsec:config_com} a configurable implementation based on OPC UA client-server is presented.

The component \textbf{\textit{SignalSpace}} consists of read external and existing internal signals. For the later processing of an observing service a differentiation between internal and external signals is not required. According to this, the internal and external available signals have to be merged to a single defined set of signals. The merge can be realized by using the introduced pattern of the Global Value Registry, which is described in detail in subsection \ref{subsec:global_registry}.

With the \textbf{\textit{Actioner}}, the last component to realize a choreography is introduced. Its responsibility is to execute configured actions resulting from a change inside the \textit{SignalSpace}. Like the signals of the \textit{SignalSpace}, the resulting actions can also be differentiated into a procedural, regulatory and interlocking level. Thereby, an action on one of these levels is often triggered by a change of a signal on the same level — procedural signals influence procedural actions, and so on. Sometimes, also actions on the procedural level can be triggered by signals from the regulatory or interlocking level. An action on the regulatory and interlocking level is a calculation that transforms certain input signals into output signals using logical and/or arithmetic functions. An action on the procedural level follows an IFTTT logic. If a defined expression is true then a defined value assignment will be executed. To implement all of those actions, the software pattern of the adaptive logic is introduced in the subsection \ref{subsec:adaptable_logic}.


## Software Pattern for Configurable Communication


The need behind this software pattern can be attributed back to the requirement to be able to connect a choreographable service to multiple other services running on several execution environments. The pattern consists of two main software parts — the \textit{Connection Manager}, which handles the server connections, and the \textit{Reader}, which executes the reading calls of a connection (see Figure \ref{figure:pattern_communication}). The active part of the communication is done by the \textit{Reader}. It represents the client side and reads information out of the server from other environments. The pattern realizes a configurable communication implementation of the OPC UA client-server approach. The client parts are configurable over defined interfaces within the server.

![pattern_communication](../Media/pattern_config_communication.png)

The \textbf{\textit{Connection Manager}} (see Figure \ref{figure:pattern_communication}) provides management capabilities for configurable OPC UA server connections based on OPC UA client function blocks. For each of the managed connections a defined \textit{Connection Handle} in form of a user-defined data type is provided. All handles are used later in an array to be forwarded to the reader block. Environments can have constraints and restrictions like a maximum number of parallel connections or parallel read requests to the server. Regarding the limits of parallel connections, there is no software-related compensation designed. Regarding the limits of parallel read requests, a scheduling algorithm is used to ensure only a defined number of parallel read requests. The number of configured readers is determined by the pattern itself. If more than the possible number of readers are used on the same connection, the scheduling will be activated automatically. The scheduling is placed within the connection manager and defines requesting slots for each of the readers during the execution.\\
The \textbf{\textit{Reader}} has access to the connection handle array and can be configured to a concrete connection by a defined \textit{HandleIndex}. The data to be read must be configured via OPC UA NodeIDs in the \textit{ReadNodeConfig}. After the connection state changes to 'connected' the reader block starts its cyclic reading, under consideration of the scheduling, if its necessary. The read data is written to a defined index (\textit{DataIndex}) of a specialized array, that represents the \textit{GlobalValueRegistry} (see subsection \ref{subsec:global_registry}).\\
A \textit{Reader} can be configured to read state related information or parameter values and process values with multiple data types (e.g. REAL, DINT, BOOL, STRING from the IEC 61131-3 \cite{61131-3}). To be able to connect to execution environments of different vendors standardized interfaces must be used (i.e. VDI/VDE/NAMUR 2658-4 \cite{2658-4}).\\
As an example for the use of this pattern, the communication of the environment PEA2 (see Figure \ref{figure:abstract_perspective}) is considered.  The environment PEA2 has a relation to the environment of PEA1 (\textit{HandleIndex} is '0') and PEA3 (\textit{HandleIndex} is '1'). This leads to two different connections that are managed by the \textit{Connection Manager}. Through the connection to PEA1 the state of the \textit{Filling} service and the interlocking information must be read. This leads to three reader blocks — one that reads the state related information and two that are used for the binary interlocking information. The three blocks are configured to use the connection with \textit{HandleIndex} 0. The connection to PEA3 requires one reader for state related information and one to connect to the measured analyzing value. Both blocks are configured to use the connection of \textit{HandleIndex} 1. With the activation of the communication, the connection is initialized, established and the namespaces table is requested. The reader block registers the nodes to be read and uses these node handles to read the values cyclically. While the communication mechanism is activated, all the configured connections are monitored actively. More details about the sequence that must be executed to interact with an OPC UA server by a PLC-integrated OPC UA client, can be found in \cite{S7OPCClientManual} or the applied standard \cite{PLCOpenOPCUA}.\\
In summary, the solution provides a configurable software pattern for a flexible communication mechanism with an M-to-N relation between \textit{Connection Manager} and \textit{Reader}. The pattern is originally developed for the use in PLC programs, but it can also be used for any systems, which supports OPC UA client and server functionality.



## Software Pattern for the Global Value Registry


As introduced in chapter \ref{sec:concept} the signal-space consists of external and internal signals, but in the course of processing a differentiation of the signals is not necessary. Therefore, to merge the external and internal signals, the pattern of the \textit{GlobalValueRegistry} is introduced (see Figure \ref{figure:pattern_registry}). It consists of three parts — the functions \textit{SetValue} and \textit{GetValue} and a global array named \textit{GlobalValueRegistry}.

![pattern_registry](../Media/pattern_global_registry.png)


The \textbf{\textit{GlobalValueRegistry}} indicates a list of values which can be accessed globally inside an execution environment. In case of a PLC program 'global' means the data can be accessed from anywhere within the PLC program. Depending on the used device type, different mechanisms can be used to solve this pattern, i.e. an undefined type like an 'any' type or a multi-variant type like an 'union' type.  To be type-safe the pattern realize this by using the user-defined data type \textit{UnionType}. The program has to take care that the registry is always up-to-date.\\
For updating the registry the function \textbf{\textit{SetValue}} (see Figure \ref{figure:pattern_registry}) shall be used. By using the \textbf{\textit{GetValue}} function (see Figure \ref{figure:pattern_registry}) the extraction of a value from the registry can be realized easily and readable for the programmer. Type checking in and out of the \textit{GlobalValueRegistry} is implemented within the get and set functions without any programmer intervention. This kind of realization is motivated by object-oriented principles like in \cite{Stutz18}.\\
In relation to the used example, the externally read signals from the PEA1 and PEA3 services can be merged and provided to be accessible for the actioner of the \textit{Dosing} service.


## Software pattern for Adaptable Logic Network


The core aspect of the choreography pattern is represented by the \textit{Actioner}. An \textit{Actioner} contains a mechanism to consume signals from the \textit{Signal-Space}, proceed them and transfer them to the automation service. Each choreographable automation service contains its own \textit{Actioner}. The software pattern of the adaptable logic is the technical foundation of the \textit{Actioner}. The pattern is presented in Figure \ref{figure:pattern_logic}. It consists of five elementary parts — four user-defined data types (UDT) and a function block (FB).\\

![pattern_logic](../Media/pattern_adaptive_logic.png)


The \textbf{\textit{UnionType}} represents a type-safe multi-variant user-defined data type. With the \textit{Selector} the current type of the value is defined. The value is then written to the selected concrete typed value. The encoding of the \textit{Selector} is given in the note inside Figure \ref{figure:pattern_logic}. The union data type is used in all other UDTs and the FB of this pattern.\\
The \textbf{\textit{ArgumentType}} represents a referencing type. Via \textit{Source} and \textit{Index}, the indexed element within the selected source list can be referenced. The encoding of the \textit{Source} is given in Figure \ref{figure:pattern_logic}. This type contains also the possibility to set a constant value. By \textit{Source} equals '-1', the \textit{Index} is ignored and the variable \textit{Const} is used as argument value. The type of the \textit{Const} variable is \textit{UnionType}.\\
The \textbf{\textit{OutputType}} is quite similar to the \textit{ArgumentType}. Regarding its behavior of the variables \textit{Source}, \textit{Index} and \textit{Const} there is no difference. The difference is the usage context as output information. At the end of the processing the referenced value or the constant value, depending on \textit{Source}, is written to the \textit{Value} variable. Due to this post-processing the results after the execution of the adaptive logic function is stored in the variable \textit{Value} of the output elements.\\
The \textbf{\textit{FunctionType}} contains several \textit{ArgumentType} references, the function \textit{Selector}, the result in the variable \textit{Out} and the return information of the function processing (\textit{Ret}). Depending on the selected function, the interpretation of the arguments are defined strictly. Using the argument references, the to be used input information is determined and processed following the selected function. The result is written to the \textit{Out} variable. The success or fail of the function processing is written to the \textit{Ret} value. As written in the note of \textit{FunctionType} in Figure \ref{figure:pattern_logic}, the list of selectable functions can be endless. Whatever can be imagined, can be implemented, selected and executed. Only the convention of a function with a fixed number of input arguments and one single output value must be fulfilled. By using an argument with \textit{Source} selector 'Logic', the \textit{Out} value of a previous function execution is used as input for the current executed function. With this kind of recursive mechanism, concatenations of functions can be defined in the logic list to create complex expressions and calculations.\\
The executive part of the adaptable logic pattern is contained in the function block \textbf{\textit{AdaptiveLogic}}. This block uses three lists containing the input, logic and output elements. The \textit{Inputs} list consists of all usable information within the adaptable logic function block. It's an array of the \textit{UnionType}. The \textit{Logics} list is an array of the type \textit{FunctionType} and provides the possible configurable function elements. The list of \textit{Outputs} is an array of the \textit{OutputType} and represents the input information for the service. The execution of the block is separated into two different loops. The first loop iterates over all elements of the \textit{Logics} list to interpret and execute each of them. The \textit{ArgumentType} references are determined and injected into the configured function. The result is written to the \textit{Out} value. The second loop iterates over the elements of the \textit{Outputs} list. As described with regard to the \textit{OutputType} the configured source value is determined and written to the \textit{Value}. Depending on the configuration of the \textit{OutputType} the value is determined out of the \textit{Inputs} list, the \textit{Logics} list, as calculated result, or out of the \textit{Outputs} list. After the iteration over both lists, the configured logic has been executed once. The results of the function block call are passed out through the \textit{Outputs} list and its \textit{Value} variables in each element. The execution principle can be attributed back to the Input-Process-Output pattern, known from cyclic working PLCs.

![actioner_example](../Media/sequence_actioner_example.png)



To complete the previously introduced examples, the actions of the \textit{Dosing} service \textit{Actioner} within the \textit{PEA2} environment are shown in the following. The \textit{Actioner} of the \textit{Dosing} services contains state information as well as interlocking information of the \textit{Filling} service within its \textit{Inputs} list. The \textit{Outputs} list contains the procedural service interface and the interlocking signal to the pump of the \textit{Dosing} service. To establish the choreography, the signals of both sides (\textit{Inputs} list and \textit{Outputs} list) must be related to create the choreographed function. The relations necessary in this example are shown in the form of a sequence diagram in Figure \ref{figure:actioner_example}.

In case of the interlocking signals two input signals (interlocks from the level switch and the valve position) must be merged by an AND-function. Both signals are zero-active and both must be true for the pump to be released. For that, the interlock signals from the \textit{Filling} service are stored inside the \textit{Inputs} list in index '4' for the level switch and in index'5' for the valve position. Both signals are referenced by a \textit{FunctionType} element (Index '5') with Selector '30' (AND-function). The result of this \textit{FunctionType} is used at the corresponding element of the \textit{Outputs} list. For that, the \textit{OutputType} is set to \textit{Source} equals '2' (means Logics), and the \textit{Index} is set to '5', because this is the index of the result inside the \textit{Logics} list. This example is presented in the upper gray box within Figure \ref{figure:actioner_example}.

In case of the procedural level, there are much more relations to define that map the state information of the \textit{Filling} service (index '6' inside the \textit{Inputs} list). All reactions depending on the state change of the \textit{Filling} service, must be mapped to the \textit{Dosing} service. As one example for such a procedural mapping, the starting phase is described. When the \textit{Filling} service changes its state to the 'Execute' state, this is the trigger to activate the 'Start' command at the core service of \textit{Dosing}. In that a simple IFTTT logic function must be configured. For that the \textit{FunctionType} must be configured in the following way. The \textit{Selector} is set to '101' (means IFTTT-Logic). This logic function, requires four input arguments of type \textit{ArgumentType}. The first argument is referenced to the state information element inside the \textit{Inputs} list, for that the \textit{Source} is set to '1' (means Inputs) with \textit{Index} set to '6'. The second parameter represents the observed state and the \textit{ArgumentType} is set to a constant value of '64' (means 'Execute'). The third parameter represents the command value, that should be forwarded to the command interface. The \textit{ArgumentType} is set to a constant value of '4' (means 'Start'). The fourth argument contains a boolean parameter which is used to parameterize the IFTTT logic. 'True' means the command is written to the Output variable within each cycle. 'False' means the command is written only once when triggered. This kind of configuration must be repeated as often as IFTTT trigger relation is required. This example is presented in the lower gray box within Figure \ref{figure:actioner_example}.